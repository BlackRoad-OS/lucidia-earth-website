<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lucidia Earth â€” Pixel-Perfect Infinite Zoom</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
        }
        #canvas-container { position: fixed; inset: 0; }

        .zoom-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 14px 28px;
            border-radius: 50px;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .zoom-level {
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(135deg, #FF1D6C, #F5A623, #2979FF, #9C27B0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Monaco', monospace;
        }
        .zoom-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.5);
        }
        .zoom-detail {
            font-size: 15px;
            color: rgba(255,255,255,0.9);
            font-weight: 600;
        }
        .zoom-scale {
            font-size: 11px;
            color: #0f0;
            font-family: 'Monaco', monospace;
        }

        .pixel-info {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            padding: 16px 20px;
            border-radius: 16px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 100;
            display: none;
        }
        .pixel-info.visible { display: block; }
        .pixel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: rgba(255,255,255,0.4);
            margin-bottom: 8px;
        }
        .pixel-grid {
            display: grid;
            grid-template-columns: repeat(8, 32px);
            gap: 4px;
            margin-top: 12px;
        }
        .pixel-cell {
            width: 32px;
            height: 32px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pixel-cell:hover {
            background: rgba(255,255,255,0.15);
            transform: scale(1.1);
        }

        .lod-stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            padding: 18px 22px;
            border-radius: 16px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 100;
            font-family: 'Monaco', monospace;
            font-size: 11px;
        }
        .lod-stat {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 5px 0;
        }
        .lod-label { color: rgba(255,255,255,0.6); }
        .lod-value { color: #0f0; font-weight: 700; }

        @keyframes pixelPulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
        .emoji-holder {
            animation: pixelPulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="zoom-indicator">
        <div class="zoom-label">Zoom Depth</div>
        <div class="zoom-level" id="zoomLevel">L0</div>
        <div class="zoom-detail" id="zoomDetail">Global View</div>
        <div class="zoom-scale" id="zoomScale">1:40,000,000</div>
    </div>

    <div class="pixel-info" id="pixelInfo">
        <div class="pixel-title">Pixel Grid (64x64)</div>
        <div id="pixelContent">Zoom deeper to see individual pixels...</div>
        <div class="pixel-grid" id="pixelGrid"></div>
    </div>

    <div class="lod-stats">
        <div class="lod-stat">
            <span class="lod-label">Triangles:</span>
            <span class="lod-value" id="triCount">0</span>
        </div>
        <div class="lod-stat">
            <span class="lod-label">Resolution:</span>
            <span class="lod-value" id="resolution">64x64</span>
        </div>
        <div class="lod-stat">
            <span class="lod-label">Pixels/mÂ²:</span>
            <span class="lod-value" id="pixelDensity">0</span>
        </div>
        <div class="lod-stat">
            <span class="lod-label">Emoji Holders:</span>
            <span class="lod-value" id="emojiCount">0</span>
        </div>
        <div class="lod-stat">
            <span class="lod-label">FPS:</span>
            <span class="lod-value" id="fps">60</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const EARTH_RADIUS = 100;
        const EARTH_CIRCUMFERENCE_KM = 40075; // At equator

        // RECURSIVE 64x64 ZOOM LEVELS (Minecraft-style)
        // Each level subdivides into 64Ã—64 blocks, recursively
        // Level N has 64^N total cells
        const ZOOM_LEVELS = [
            { name: 'Planet', altitude: 300, blocks: 1, cells: 1, scale: '64Ã—64 km/block' },                    // L0: 1 block (whole planet)
            { name: 'Superchunk', altitude: 200, blocks: 64, cells: 64, scale: '1Ã—1 km/block' },                // L1: 64 blocks
            { name: 'Megachunk', altitude: 140, blocks: 64*64, cells: 4096, scale: '16Ã—16 m/block' },           // L2: 4,096 blocks
            { name: 'Chunk', altitude: 100, blocks: 64*64*64, cells: 262144, scale: '25Ã—25 cm/block' },         // L3: 262K blocks
            { name: 'Section', altitude: 70, blocks: Math.pow(64,4), cells: Math.pow(64,4), scale: '4Ã—4 mm/block' },     // L4: 16.7M blocks
            { name: 'Block', altitude: 50, blocks: Math.pow(64,5), cells: Math.pow(64,5), scale: '62 Î¼m/block' },        // L5: 1.07B blocks
            { name: 'Tile', altitude: 35, blocks: Math.pow(64,6), cells: Math.pow(64,6), scale: '1 Î¼m/block' },          // L6: 68.7B blocks
            { name: 'Cell', altitude: 25, blocks: Math.pow(64,7), cells: Math.pow(64,7), scale: '15 nm/block' },         // L7: 4.4T blocks
            { name: 'Voxel', altitude: 18, blocks: Math.pow(64,8), cells: Math.pow(64,8), scale: '234 pm/block' },       // L8: 281T blocks
            { name: 'Atom', altitude: 12, blocks: Math.pow(64,9), cells: Math.pow(64,9), scale: '3.7 pm/block' },        // L9: 18Q blocks
            { name: 'Subatomic', altitude: 8, blocks: Math.pow(64,10), cells: Math.pow(64,10), scale: '57 fm/block' },   // L10: 1.15Qa blocks
            { name: 'Quantum', altitude: 5, blocks: Math.pow(64,11), cells: Math.pow(64,11), scale: '0.9 fm/block' },    // L11: 73.8Qa blocks
            { name: 'Planck', altitude: 3, blocks: Math.pow(64,12), cells: Math.pow(64,12), scale: '14 am/block' },      // L12: 4.7Qi blocks
            { name: 'Sub-Planck', altitude: 2, blocks: Math.pow(64,13), cells: Math.pow(64,13), scale: '0.2 am/block' }, // L13: 302Qi blocks
            { name: 'Pixel Layer 1', altitude: 1.2, blocks: Math.pow(64,14), cells: Math.pow(64,14), scale: '64Ã—64 pixels' }, // L14
            { name: 'Pixel Layer 2', altitude: 0.8, blocks: Math.pow(64,15), cells: Math.pow(64,15), scale: '64Ã—64 pixels' }, // L15
            { name: 'Emoji Holder (64Ã—64)', altitude: 0.5, blocks: Math.pow(64,16), cells: Math.pow(64,16), scale: '1 pixel' } // L16: FINAL PIXEL
        ];

        // Emoji sets for pixel-level rendering
        const EMOJI_SETS = {
            agent: ['ğŸ¤–', 'ğŸ‘¤', 'ğŸ‘©', 'ğŸ‘¨', 'ğŸ§‘', 'ğŸ‘¶', 'ğŸ§’', 'ğŸ‘¦', 'ğŸ‘§'],
            nature: ['ğŸŒ³', 'ğŸŒ²', 'ğŸŒ´', 'ğŸŒµ', 'ğŸŒ¾', 'ğŸŒ¿', 'â˜˜ï¸', 'ğŸ€', 'ğŸŒ±', 'ğŸŒ¸', 'ğŸŒº', 'ğŸŒ»', 'ğŸŒ¹'],
            animals: ['ğŸ•', 'ğŸˆ', 'ğŸ¦', 'ğŸ¦…', 'ğŸ¦†', 'ğŸ¿ï¸', 'ğŸ¦Œ', 'ğŸ', 'ğŸ„', 'ğŸ–', 'ğŸ“', 'ğŸ‡'],
            buildings: ['ğŸ ', 'ğŸ¡', 'ğŸ¢', 'ğŸ¬', 'ğŸ­', 'ğŸ°', 'â›ª', 'ğŸ›ï¸', 'ğŸ—¼'],
            vehicles: ['ğŸš—', 'ğŸš•', 'ğŸš™', 'ğŸšŒ', 'ğŸš', 'ğŸï¸', 'ğŸš“', 'ğŸš‘', 'ğŸš’', 'ğŸšš'],
            items: ['ğŸ“¦', 'ğŸ', 'ğŸ”§', 'ğŸ”¨', 'âš™ï¸', 'ğŸª‘', 'ğŸ›‹ï¸', 'ğŸšª', 'ğŸªŸ'],
            food: ['ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ¥•', 'ğŸŒ½', 'ğŸ'],
            weather: ['â˜€ï¸', 'ğŸŒ¤ï¸', 'â›…', 'ğŸŒ¥ï¸', 'â˜ï¸', 'ğŸŒ§ï¸', 'â›ˆï¸', 'ğŸŒ©ï¸', 'â„ï¸']
        };

        let currentZoomLevel = 0;
        let targetZoomLevel = 0;
        let scene, camera, renderer;
        let earth, pixelGrid;
        let spherical = { theta: 0, phi: Math.PI / 3, radius: ZOOM_LEVELS[0].altitude };
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };

        let lodMeshes = new Map();
        let emojiHolders = [];
        let frameCount = 0;
        let lastTime = performance.now();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000005);
            scene.fog = new THREE.FogExp2(0x000005, 0.0001);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 10000);
            updateCamera();

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                logarithmicDepthBuffer: true,
                precision: 'highp'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createStars();
            createLights();
            createEarthLOD();
            setupControls();
            updateZoomUI();

            animate();
        }

        function createStars() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(15000 * 3);
            for (let i = 0; i < 15000; i++) {
                const r = 1500 + Math.random() * 3000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                pos[i * 3 + 2] = r * Math.cos(phi);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            scene.add(new THREE.Points(geo, new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                sizeAttenuation: true
            })));
        }

        function createLights() {
            const sun = new THREE.DirectionalLight(0xffffff, 1.8);
            sun.position.set(500, 300, 500);
            scene.add(sun);

            scene.add(new THREE.AmbientLight(0x404060, 0.6));
            scene.add(new THREE.HemisphereLight(0x88aaff, 0x332211, 0.4));
        }

        function createEarthLOD() {
            const lodGroup = new THREE.Group();

            // Only create first 12 levels with actual geometry (beyond that is too memory intensive)
            for (let i = 0; i < Math.min(12, ZOOM_LEVELS.length); i++) {
                const level = ZOOM_LEVELS[i];
                const [segW, segH] = level.resolution;
                const geo = new THREE.SphereGeometry(EARTH_RADIUS, segW, segH);
                const triCount = geo.index ? geo.index.count / 3 : (segW * segH * 2);

                const mat = new THREE.MeshPhongMaterial({
                    color: 0x2d5a3d,
                    emissive: 0x0a1a0a,
                    shininess: 12,
                    wireframe: i > 10 // Wireframe for deepest levels
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.visible = (i === 0);
                mesh.userData.lodLevel = i;
                mesh.userData.triCount = triCount;

                lodMeshes.set(i, mesh);
                lodGroup.add(mesh);

                console.log(\`LOD L\${i} (\${level.name}): \${triCount.toLocaleString()} triangles at \${segW}x\${segH}\`);
            }

            earth = lodGroup;
            scene.add(earth);

            // Create pixel grid for deepest zoom (rendered as sprites)
            createPixelGrid();
        }

        function createPixelGrid() {
            pixelGrid = new THREE.Group();
            pixelGrid.visible = false;
            scene.add(pixelGrid);

            // Generate 64x64 emoji holders
            const gridSize = 64;
            const spacing = 0.1;

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');

                    // Random emoji from all categories
                    const category = Object.keys(EMOJI_SETS)[Math.floor(Math.random() * Object.keys(EMOJI_SETS).length)];
                    const emoji = EMOJI_SETS[category][Math.floor(Math.random() * EMOJI_SETS[category].length)];

                    ctx.font = '48px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(emoji, 32, 32);

                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    const sprite = new THREE.Sprite(material);

                    sprite.position.set(
                        (x - gridSize / 2) * spacing,
                        EARTH_RADIUS + 0.5,
                        (y - gridSize / 2) * spacing
                    );
                    sprite.scale.set(spacing * 0.8, spacing * 0.8, 1);
                    sprite.userData = { emoji, category };

                    pixelGrid.add(sprite);
                    emojiHolders.push(sprite);
                }
            }
        }

        function setupControls() {
            window.addEventListener('resize', onResize);
            renderer.domElement.addEventListener('mousedown', e => {
                isDragging = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('wheel', e => {
                e.preventDefault();
                handleZoom(e.deltaY);
            }, { passive: false });

            window.addEventListener('keydown', e => {
                if (e.key === 'Escape') resetToGlobal();
                if (e.key === '=') handleZoom(-50);
                if (e.key === '-') handleZoom(50);
            });
        }

        function handleZoom(delta) {
            spherical.radius = Math.max(0.3, Math.min(400, spherical.radius + delta * 0.15));

            for (let i = ZOOM_LEVELS.length - 1; i >= 0; i--) {
                if (spherical.radius <= ZOOM_LEVELS[i].altitude * 1.15) {
                    targetZoomLevel = i;
                    break;
                }
            }

            updateLOD();
        }

        function resetToGlobal() {
            targetZoomLevel = 0;
            spherical.radius = ZOOM_LEVELS[0].altitude;
            updateLOD();
        }

        function updateLOD() {
            if (currentZoomLevel !== targetZoomLevel) {
                currentZoomLevel = targetZoomLevel;

                // Update mesh visibility
                lodMeshes.forEach((mesh, level) => {
                    mesh.visible = (level === Math.min(currentZoomLevel, 11));
                });

                // Show pixel grid at deepest level
                pixelGrid.visible = (currentZoomLevel >= 15);
                document.getElementById('pixelInfo').classList.toggle('visible', currentZoomLevel >= 15);

                updateZoomUI();
            }
        }

        function updateZoomUI() {
            const level = ZOOM_LEVELS[currentZoomLevel];
            document.getElementById('zoomLevel').textContent = \`L\${currentZoomLevel}\`;
            document.getElementById('zoomDetail').textContent = level.name;
            document.getElementById('zoomScale').textContent = level.scale;

            const mesh = lodMeshes.get(Math.min(currentZoomLevel, 11));
            const triCount = mesh ? mesh.userData.triCount : 0;
            document.getElementById('triCount').textContent = triCount.toLocaleString();
            document.getElementById('resolution').textContent = \`\${level.resolution[0]}x\${level.resolution[1]}\`;

            const pixelsPerM2 = Math.pow(2, currentZoomLevel);
            document.getElementById('pixelDensity').textContent = pixelsPerM2.toLocaleString();
            document.getElementById('emojiCount').textContent = pixelGrid.visible ? emojiHolders.length.toLocaleString() : '0';
        }

        function updateCamera() {
            camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
            camera.position.y = spherical.radius * Math.cos(spherical.phi);
            camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
            camera.lookAt(0, 0, 0);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            const dx = e.clientX - prevMouse.x;
            const dy = e.clientY - prevMouse.y;
            spherical.theta -= dx * 0.005;
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + dy * 0.005));
            updateCamera();
            prevMouse = { x: e.clientX, y: e.clientY };
        }

        function animate() {
            requestAnimationFrame(animate);

            updateCamera();
            earth.rotation.y += 0.0001;

            // Rotate emoji holders to face camera when visible
            if (pixelGrid.visible) {
                emojiHolders.forEach(sprite => {
                    sprite.lookAt(camera.position);
                });
            }

            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                const fps = Math.round(frameCount * 1000 / (now - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = now;
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
